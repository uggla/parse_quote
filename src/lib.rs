use nom::{
    bytes::complete::tag,
    error::{Error, ErrorKind, ParseError},
    IResult,
};

#[derive(Debug, PartialEq, Eq)]
struct Data {
    /*
    Data Type 	2 	B6
    Information Type 	2 	03
    Market Type 	1 	4
    Issue code 	12 	ISIN code
    Issue seq.-no. 	3
    Market Status Type 	2
    Total bid quote volume 	7
    Best bid price(1st) 	5 	Decimals
    Best bid quantity(1st) 	7 	Decimals
    Best bid price(2nd) 	5
    Best bid quantity(2nd) 	7
    Best bid price(3rd) 	5
    Best bid quantity(3rd) 	7
    Best bid price(4th) 	5
    Best bid quantity(4th) 	7
    Best bid price(5th) 	5
    Best bid quantity(5th) 	7
    Total ask quote volume 	7
    Best ask price(1st) 	5
    Best ask quantity(1st) 	7
    Best ask price(2nd) 	5
    Best ask quantity(2nd) 	7
    Best ask price(3rd) 	5
    Best ask quantity(3rd) 	7
    Best ask price(4th) 	5
    Best ask quantity(4th) 	7
    Best ask price(5th) 	5
    Best ask quantity(5th) 	7
    No. of best bid valid quote(total) 	5
    No. of best bid quote(1st) 	4
    No. of best bid quote(2nd) 	4
    No. of best bid quote(3rd) 	4
    No. of best bid quote(4th) 	4
    No. of best bid quote(5th) 	4
    No. of best ask valid quote(total) 	5
    No. of best ask quote(1st) 	4
    No. of best ask quote(2nd) 	4
    No. of best ask quote(3rd) 	4
    No. of best ask quote(4th) 	4
    No. of best ask quote(5th) 	4
    Quote accept time 	8 	HHMMSSuu
    End of Message 	1 	0xff
    */
}

// fn parse_quote_packet(input: &[u8]) -> IResult<&[u8], Data> {
//     let (input, magic) = tag("B6034")(input)?;
//     dbg!(magic);
//
//     todo!();
// }

// Custom error type to hold a message and optionally the `nom::ErrorKind`
#[derive(Debug, PartialEq, Eq)]
struct CustomError<'a> {
    input: &'a [u8],
    message: &'static str,
}

// Implement `ParseError` for `CustomError`
impl<'a> ParseError<&'a [u8]> for CustomError<'a> {
    fn from_error_kind(input: &'a [u8], _kind: ErrorKind) -> Self {
        CustomError {
            input,
            message: "Error occurred during parsing",
        }
    }

    fn append(input: &'a [u8], _kind: ErrorKind, other: Self) -> Self {
        other
    }

    fn from_char(input: &'a [u8], _: char) -> Self {
        CustomError {
            input,
            message: "Unexpected character during parsing",
        }
    }
}

// Function to parse the quote packet with a custom error
fn parse_quote_packet(input: &[u8]) -> IResult<&[u8], &'static str, CustomError> {
    // Try to match the magic tag "B6034"
    let truc = match tag::<&str, &[u8], CustomError>("B6034")(input) {
        Ok((remaining_input, magic)) => {
            dbg!(magic); // For debugging, shows the matched tag
                         // Placeholder for further logic
            Ok((remaining_input, magic))
        }
        Err(_) => {
            // Return a custom error message
            Err(nom::Err::Error(CustomError {
                input,
                message: "Expected 'B6034' but didn't find it",
            }))
        }
    };

    let (input, magic) = truc.unwrap();
    // let (input, magic) = tag("B6034")(input)?;
    todo!();
}

#[cfg(test)]
mod test {

    use pretty_assertions::assert_eq;

    use crate::CustomError;

    use super::parse_quote_packet;

    #[test]
    fn test_parse_quote_packet_ok() {
        const PKT_OK: &[u8] = &[
            0x42, 0x36, 0x30, 0x33, 0x34, 0x4b, 0x52, 0x34, 0x32, 0x30, 0x31, 0x46, 0x33, 0x32,
            0x37, 0x30, 0x35, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x32, 0x32, 0x36, 0x38,
            0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
            0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
            0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
            0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
            0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x37, 0x32, 0x32, 0x34, 0x30, 0x30,
            0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
            0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
            0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
            0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
            0x30, 0x30, 0x30, 0x30, 0x39, 0x34, 0x37, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
            0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
            0x30, 0x33, 0x36, 0x35, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
            0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x38, 0x35, 0x39,
            0x35, 0x39, 0x39, 0x37, 0xff,
        ];

        let pkt = parse_quote_packet(PKT_OK).unwrap();
        println!("{:?}", pkt);
    }

    #[test]
    fn test_parse_quote_packet_ko() {
        const PKT_KO: &[u8] = &[
            0x42, 0x36, 0x30, 0x31, 0x34, 0x4b, 0x52, 0x34, 0x31, 0x30, 0x31, 0x46, 0x33, 0x30,
            0x30, 0x30, 0x38, 0x30, 0x31, 0x31, 0x30, 0x30, 0x31, 0x34, 0x37, 0x34, 0x37, 0x20,
            0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x20, 0x30, 0x30,
            0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x20, 0x30, 0x30, 0x30, 0x30,
            0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x20, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
            0x30, 0x30, 0x30, 0x30, 0x30, 0x20, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
            0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x36, 0x30, 0x31, 0x20, 0x30, 0x30, 0x30, 0x30,
            0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x20, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
            0x30, 0x30, 0x30, 0x30, 0x30, 0x20, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
            0x30, 0x30, 0x30, 0x20, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
            0x30, 0x20, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
            0x32, 0x30, 0x38, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
            0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x34, 0x38,
            0x38, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
            0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x38, 0x35, 0x39, 0x35, 0x39, 0x39,
            0x38, 0xff,
        ];

        let pkt = parse_quote_packet(PKT_KO);
        assert!(pkt.is_err());
        assert_eq!(
            pkt.unwrap_err(),
            nom::Err::Error(CustomError {
                input: PKT_KO,
                message: "Expected 'B6034' but didn't find it"
            })
        );
    }
}
